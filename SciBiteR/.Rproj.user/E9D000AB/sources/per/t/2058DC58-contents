#' TExpress
#'
#' \code{TExpress} passes user-specified information to a TExpress API endpoint.
#' Operation of this function requires a valid license to TExpress provided by
#' SciBite.
#'
#' @param endpoint A string specifying the IP and API endpoint of TERMite.
#'   Defaults to "http://localhost:9090/texpress" representing a typical
#'   installation.
#' @param input A string representing either text to be processed with TERMite
#'   or an absolute filepath to the file to be processed.
#' @param inputFile A boolean, with TRUE indicating that \code{input} should be
#'   considered a filepath. Defaults to \code{FALSE}.
#' @param inputFileFormat A string representing the format of the file to be
#'   processed. Requires that \code{file} be \code{TRUE}. Defaults to
#'   \code{NULL}
#' @param outputFile A string representing the absolute filepath where output
#'   will be written. Defaults to \code{NULL}, output will be written to
#'   terminal.
#' @param outputFormat A string representing the desired format of output.
#'   Defaults to "json".
#' @param pattern A string representing a valid TExpress pattern. If
#'   \code{NULL}, user must supply a bundle to be used.
#' @param bundle A string representing the bundle to be used. Defaults to
#'   \code{NULL}, no bundle will be used.
#' @param options A named list enumerating the runtime options to be used. Names
#'   correspond to valid TERMite options and values correspond to valid option
#'   settings.
#' @export

TExpress <- function(endpoint="http://localhost:9090/texpress",
                    input,
                    inputFile = FALSE,
                    inputFileFormat = NULL,
                    outputFile = NULL,
                    outputFormat = "json",
                    pattern,
                    bundle = NULL,
                    options = NULL){
  ###############
  # Error Block #
  ###############

  # Input file specificed but no format specified
  if (inputFile != FALSE & is.null(inputFileFormat)) stop("Must specify file format of input file.")

  ####################
  # Payload creation #
  ####################

  # Initialize List

  payload <- list(
    # Payload Core
    output = outputFormat,
    opts = paste(names(options), options, sep='=', collapse='&'),

    # Hidden Options
    docFilter='',
    maxDocs='',
    tabStyle='')

  # Input control

  if (inputFile) {
    payload[['binary']] <- httr::upload_file(input)
    payload[['format']] <- inputFileFormat
  }
  else {
    payload[["text"]] <- input
    payload[["format"]] <- "txt"
  }

  # Pattern control

  if (!is.null(pattern)) {
    payload[['pattern']] <- pattern
    payload[['bundle']] <- ''
  }
  else {
    payload[['pattern']] <- ''
    payload[['bundle']] <- bundle
  }

  ########
  # POST #
  ########

  response_raw <- httr::POST(
    url = endpoint,
    body = payload,
    encode = "multipart"
  )

  ##########
  # Output #
  ##########

  if (!is.null(outputFile)) {
    response <- httr::content(response_raw, as = "text")
    write(response, file=outputFile)
  }
  else {
    response <- httr::content(response_raw, as = "parsed")
    View(response)
  }
}
