#' TERMite
#'
#' \code{termite} passes user-specified information to a TERMite API endpoint.
#' Operation of this function requires a valid license to TERMite provided by
#' SciBite.
#'
#' @param endpoint A string specifying the IP and API endpoint of TERMite.
#'   Defaults to "http://localhost:9090/termite" representing a typical
#'   installation.
#' @param input A string representing either text to be processed with TERMite
#'   or an absolute filepath to the file to be processed.
#' @param inputFile A boolean, with TRUE indicating that \code{input} should be
#'   considered a filepath. Defaults to \code{FALSE}.
#' @param inputFileFormat A string representing the format of the file to be
#'   processed. Requires that \code{file} be \code{TRUE}. Defaults to
#'   \code{NULL}
#' @param outputFile A string representing the absolute filepath where output
#'   will be written. Defaults to \code{NULL}, output will be written to
#'   terminal.
#' @param outputFormat A string representing the desired format of output.
#'   Defaults to "json".
#' @param VOCabs A character vector enumerating the VOCabs to be used for
#'   annotation. Defaults to \code{NULL}, all primary VOCabs will be applied.
#' @param options A named list enumerating the runtime options to be used. Names
#'   correspond to valid TERMite options and values correspond to valid option
#'   settings.
#' @export

TERMite <- function(endpoint="http://localhost:9090/termite",
                    input,
                    inputFile = FALSE,
                    inputFileFormat = NULL,
                    outputFile = NULL,
                    outputFormat = "json",
                    VOCabs = NULL,
                    options = NULL){
  ###############
  # Error Block #
  ###############

  # Input file specificed but no format specified
  if (inputFile != FALSE & is.null(inputFileFormat)) stop("Must specify file format of input file.")

  ####################
  # Payload creation #
  ####################

  # Initialize List

  payload <- list(
    # Payload Core
    output = outputFormat,
    entities = paste(VOCabs, collapse=','),
    opts = paste(names(options), options, sep='=', collapse='&'),

    # Hidden Options
    rejectMinor = 'on',
    hitFilterWorkspace= '',
    hitFilter='',
    docFilter='',
    fieldTarget='',
    sfunc='',
    wrk='',
    priority='',
    bginfo='',
    username='',
    usertoken='',
    togswapon ='',
    format_off='',
    output_off='',
    bundle='',
    maxDocs='',
    tabStyle='')

  # Input control

  if (inputFile) {
    payload[['binary']] <- httr::upload_file(input)
    payload[['format']] <- inputFileFormat
  }
  else {
    payload[["text"]] <- input
    payload[["format"]] <- "txt"
  }

  ########
  # POST #
  ########

  response_raw <- httr::POST(
    url = endpoint,
    body = payload,
    encode = "multipart"
  )

  #response_json <- fromJSON(response, flatten = FALSE)

  ##########
  # Output #
  ##########

  if (!is.null(outputFile)) {
    response <- httr::content(response_raw, as = "text")
    write(response, file=outputFile)
  }
  else {
    response <- httr::content(response_raw, as = "parsed")
    View(response)
  }
}
