if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityvector <- entityHits
entityHits <- fill_empty_values(entityHits)
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=28))
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
colnames(allHitsDF) <- columnNames
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
fmDataDF2 <- get_entity_hits_from_json(TERMITE_RESPONSE_JSON_MULTIDOC)
View(TERMITE_RESPONSE_JSON_MULTIDOC)
get_entity_hits_from_json <- function(termite_json_response,
columns_to_return = c("hitID", "entityType", "name", "hitCount", "totnosyns", "goodSynCount",
"realSynList", "score", "exact_string", "frag_vector_array")) {
fill_empty_values <- function(val) {
# fills empty results in hit vectors
for (x in 1:length(val)) {
if (length(val[[x]]) == 0) {
val[[x]] <- ""
}
}
return(val)
}
allHitsDF = data.frame()
columnNames <- c()
# Payload processing -----
if ('RESP_MULTIDOC_PAYLOAD' %in% names(termite_json_response)) {
# Multidoc processing -----
columns_to_return <- append(columns_to_return, c("docID"))
for (document in termite_json_response[['RESP_MULTIDOC_PAYLOAD']]) {
for (entity_type in document) {
columnNames <- (names(entity_type[[1]]))
print(length(columnNames))
grabInfo <- function(var) {
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return("NA")
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
print(columnNames)
print(entityHits)
print(length(columnNames) == length(entityHits))
entityHits <- fill_empty_values(entityHits)
print("working1")
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
print(entityHitsDF)
print("working2")
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
print("working3")
}
}
} else {
# Single payload processing -----
#columnNames <- names(termite_json_response[['RESP_PAYLOAD']][[1]][[1]])
for (entity_type in termite_json_response[['RESP_PAYLOAD']]) {
columnNames <- (names(entity_type[[1]]))
grabInfo <- function(var) {
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityvector <- entityHits
entityHits <- fill_empty_values(entityHits)
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=28))
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
colnames(allHitsDF) <- columnNames
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
fmDataDF2 <- get_entity_hits_from_json(TERMITE_RESPONSE_JSON_MULTIDOC)
View(fmDataDF2)
get_entity_hits_from_json <- function(termite_json_response,
columns_to_return = c("hitID", "entityType", "name", "hitCount", "totnosyns", "goodSynCount",
"realSynList", "score", "exact_string", "frag_vector_array")) {
fill_empty_values <- function(val) {
# fills empty results in hit vectors
for (x in 1:length(val)) {
if (length(val[[x]]) == 0) {
val[[x]] <- ""
}
}
return(val)
}
allHitsDF = data.frame()
columnNames <- c()
# Payload processing -----
if ('RESP_MULTIDOC_PAYLOAD' %in% names(termite_json_response)) {
# Multidoc processing -----
columns_to_return <- append(columns_to_return, c("docID"))
for (document in termite_json_response[['RESP_MULTIDOC_PAYLOAD']]) {
for (entity_type in document) {
columnNames <- (names(entity_type[[1]]))
print(length(columnNames))
grabInfo <- function(var) {
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return("NA")
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
print(columnNames)
print(entityHits)
print(length(columnNames) == length(entityHits))
#entityHits <- fill_empty_values(entityHits)
print("working1")
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
print(entityHitsDF)
print("working2")
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
print("working3")
}
}
} else {
# Single payload processing -----
#columnNames <- names(termite_json_response[['RESP_PAYLOAD']][[1]][[1]])
for (entity_type in termite_json_response[['RESP_PAYLOAD']]) {
columnNames <- (names(entity_type[[1]]))
grabInfo <- function(var) {
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityvector <- entityHits
entityHits <- fill_empty_values(entityHits)
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=28))
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
colnames(allHitsDF) <- columnNames
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
fmDataDF2 <- get_entity_hits_from_json(TERMITE_RESPONSE_JSON_MULTIDOC)
View(fmDataDF2)
get_entity_hits_from_json <- function(termite_json_response,
columns_to_return = c("hitID", "entityType", "name", "hitCount", "totnosyns", "goodSynCount",
"realSynList", "score", "exact_string", "frag_vector_array")) {
fill_empty_values <- function(val) {
# fills empty results in hit vectors
for (x in 1:length(val)) {
if (length(val[[x]]) == 0) {
val[[x]] <- ""
}
}
return(val)
}
allHitsDF = data.frame()
columnNames <- c()
# Payload processing -----
if ('RESP_MULTIDOC_PAYLOAD' %in% names(termite_json_response)) {
# Multidoc processing -----
columns_to_return <- append(columns_to_return, c("docID"))
for (document in termite_json_response[['RESP_MULTIDOC_PAYLOAD']]) {
for (entity_type in document) {
columnNames <- (names(entity_type[[1]]))
print(length(columnNames))
grabInfo <- function(var) {
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
print(columnNames)
print(entityHits)
print(length(columnNames) == length(entityHits))
#entityHits <- fill_empty_values(entityHits)
print("working1")
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
print(entityHitsDF)
print("working2")
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
print("working3")
}
}
} else {
# Single payload processing -----
#columnNames <- names(termite_json_response[['RESP_PAYLOAD']][[1]][[1]])
for (entity_type in termite_json_response[['RESP_PAYLOAD']]) {
columnNames <- (names(entity_type[[1]]))
grabInfo <- function(var) {
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityvector <- entityHits
entityHits <- fill_empty_values(entityHits)
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=28))
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
colnames(allHitsDF) <- columnNames
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
fmDataDF2 <- get_entity_hits_from_json(TERMITE_RESPONSE_JSON_MULTIDOC)
View(fmDataDF2)
get_entity_hits_from_json <- function(termite_json_response,
columns_to_return = c("hitID", "entityType", "name", "hitCount", "totnosyns", "goodSynCount",
"realSynList", "score", "exact_string", "frag_vector_array")) {
fill_empty_values <- function(val) {
# fills empty results in hit vectors
for (x in 1:length(val)) {
if (length(val[[x]]) == 0) {
val[[x]] <- ""
}
}
return(val)
}
allHitsDF = data.frame()
columnNames <- c()
# Payload processing -----
if ('RESP_MULTIDOC_PAYLOAD' %in% names(termite_json_response)) {
# Multidoc processing -----
columns_to_return <- append(columns_to_return, c("docID"))
for (document in termite_json_response[['RESP_MULTIDOC_PAYLOAD']]) {
for (entity_type in document) {
columnNames <- (names(entity_type[[1]]))
print(length(columnNames))
grabInfo <- function(var) {
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
print(columnNames)
print(entityHits)
print(length(columnNames) == length(entityHits))
#entityHits <- fill_empty_values(entityHits)
print("working1")
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
print(entityHitsDF)
print("working2")
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
print("working3")
}
}
} else {
# Single payload processing -----
#columnNames <- names(termite_json_response[['RESP_PAYLOAD']][[1]][[1]])
for (entity_type in termite_json_response[['RESP_PAYLOAD']]) {
columnNames <- (names(entity_type[[1]]))
grabInfo <- function(var) {
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityvector <- entityHits
entityHits <- fill_empty_values(entityHits)
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=28))
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
fmDataDF2 <- get_entity_hits_from_json(TERMITE_RESPONSE_JSON_MULTIDOC)
View(fmDataDF2)
library(SciBiteR)
endpoint <- "http://localhost:9090/termite"
input <- "macrophage colony stimulating factor"
inputFile <- FALSE
inputFileFormat <- NULL
outputFile <- NULL
outputFormat <- "json"
VOCabs <- NULL
options <- list("subsume" = "false", "rejectAmbig" = "true")
TERMite(endpoint="http://localhost:9090/termite",
input = input,
inputFile = inputFile,
inputFileFormat = inputFileFormat,
outputFile = outputFile,
outputFormat = outputFormat,
VOCabs = VOCabs,
options = options)
endpoint <- "http://localhost:9090/termite"
input <- "macrophage colony stimulating factor"
inputFile <- FALSE
inputFileFormat <- NULL
outputFile <- NULL
outputFormat <- "json"
VOCabs <- NULL
options <- list("subsume" = "false", "rejectAmbig" = "true")
trmiteResponse <- TERMite(endpoint="http://localhost:9090/termite",
input = input,
inputFile = inputFile,
inputFileFormat = inputFileFormat,
outputFile = outputFile,
outputFormat = outputFormat,
VOCabs = VOCabs,
options = options)
responseDF <- get_entity_hits_from_json(trmiteResponse)
get_entity_hits_from_json <- function(termite_json_response,
columns_to_return = c("hitID", "entityType", "name", "hitCount", "totnosyns", "goodSynCount",
"realSynList", "score", "exact_string", "frag_vector_array")) {
allHitsDF = data.frame()
# Payload processing -----
if ('RESP_MULTIDOC_PAYLOAD' %in% names(termite_json_response)) {
# Multidoc processing -----
columns_to_return <- append(columns_to_return, c("docID"))
for (document in termite_json_response[['RESP_MULTIDOC_PAYLOAD']]) {
for (entity_type in document) {
columnNames <- (names(entity_type[[1]]))
print(length(columnNames))
grabInfo <- function(var) {
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
} else {
# Single payload processing -----
#columnNames <- names(termite_json_response[['RESP_PAYLOAD']][[1]][[1]])
for (entity_type in termite_json_response[['RESP_PAYLOAD']]) {
columnNames <- (names(entity_type[[1]]))
grabInfo <- function(var) {
#print(paste("Variable", var, sep=" "))
sapply(entity_type, function(x) returnData(x, var))
}
returnData <- function(x, var) {
# get data - entries with multiple values are converted to pipe separated character
# Source: http://zevross.com/blog/2015/02/12/using-r-to-download-and-parse-json-an-example-using-data-from-an-open-data-portal/
if(!is.null( x[[var]])){
if (!is.list(typeof(x[[var]]))) {
return(stringr::str_c(as.character(x[[var]]), collapse = ' | '))
}
}else{
return(NA)
}
}
# get values and return dataframe with 28 columns
entityHits <- as.vector(sapply(columnNames, grabInfo))
entityHitsDF <- as.data.frame(matrix(entityHits, ncol=length(columnNames)))
colnames(entityHitsDF) <- columnNames
allHitsDF <- plyr::rbind.fill(allHitsDF, entityHitsDF)
}
}
# Output -----
returnDF <- allHitsDF[, columns_to_return]
return(allHitsDF)
}
responseDF <- get_entity_hits_from_json(trmiteResponse)
endpoint <- "http://localhost:9090/termite"
input <- "macrophage colony stimulating factor"
inputFile <- FALSE
inputFileFormat <- NULL
outputFile <- NULL
outputFormat <- "json"
VOCabs <- NULL
options <- list("subsume" = "false", "rejectAmbig" = "true")
trmiteResponse <- TERMite(endpoint="http://localhost:9090/termite",
input = input,
inputFile = inputFile,
inputFileFormat = inputFileFormat,
outputFile = outputFile,
outputFormat = outputFormat,
VOCabs = VOCabs,
options = options)
termitedf <- get_entity_hits_from_json(trmiteResponse)
library(SciBiteR)
endpoint <- "http://localhost:9090/termite"
input <- "macrophage colony stimulating factor"
inputFile <- FALSE
inputFileFormat <- NULL
outputFile <- NULL
outputFormat <- "json"
VOCabs <- NULL
options <- list("subsume" = "false", "rejectAmbig" = "true")
trmiteResponse <- TERMite(endpoint="http://localhost:9090/termite",
input = input,
inputFile = inputFile,
inputFileFormat = inputFileFormat,
outputFile = outputFile,
outputFormat = outputFormat,
VOCabs = VOCabs,
options = options)
responseDF <- get_entity_hits_from_json(trmiteResponse)
gc(reset=TRUE)
rm(list = ls())
gc()
